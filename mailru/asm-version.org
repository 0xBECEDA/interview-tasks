#+STARTUP: showall indent hidestars
~Задание:~
Пользователь вводит число с консоли. Вывести все числа, меньшие данного,
и не имеющие единиц в соседних битах.

~Общая алгоритм решения:~
- прочитать число с консоли как строку
- перевести строку с числом в само число
- посчитать кол-во бит в числе
- выделить память для всех чисел в диапазоне от 0 до данного числа (нужен
  запас по памяти)
- сгенерировать число-проверку: оно имеет то же кол-во бит, что и данное
  число, старшие 2 разряда заполнены единицами, остальные - нулями.
  Если на вход мы получили число 10010110, то число проверка будет 11000000
- сгенерировать все числа от 0 до данного числа. Будем называть их
  числами-параметрами
- на каждое число-параметр с помощью ~and~ многократно наложить число
  проверку,последовательно сдигая биты на 1 вправо у
  числа-проверки. Повторяем данное действие до тех пор, пока
  число-проверка не станет равно единице - тогда мы считаем, что у
  текущего числа нет единиц в соседних битах и мы зписываем его в
  память -  или мы не обнаружим единицы в соседних битах - тогда мы
  прекращаем анализировать текущее число и приступаем к следующему.

Пример:
Дано на вход число 10110. Его число проверка: 11000
1 итерация:
and 10110 11000 = 10000
2 итерация:
and 10110 01100 = 00100
3 итерация:
and 10110 00110 = 00110
Число не подходит! Приступаем к следующему!

Шапка и строка для обработки ошибки выделения памяти:

#+NAME: head
#+BEGIN_SRC asm
      .file	   "asm-version.s"
      .section	.rodata

  allocation_error_msg:
      .string	"NULL pointer. Allocation memory error!\n"

#+END_SRC

В ~main~ происходит следующее:
- пролог
- резерв места на стеке для хранения параметров
- чтение числа с консоли
- преобразование числа в строку
- в слечае если преобразование прошло успешно, идем дальше
- иначе выходим

#+NAME: main
#+BEGIN_SRC asm

      .globl	main
      .type	main, @function

  main:

      pushq	%rbp                   # пролог
      movq	%rsp, %rbp

      subq	$200, %rsp             # резерв памяти

      movq	stdin(%rip), %rdx      # грузим адрес stdin

      leaq	-72(%rbp), %rdi        # грузим адрес, куда следует записывать прочитанное
      movl	$64, %esi              # кол-во байт, которые надо считать
      call	fgets

      xorl	%eax, %eax

      movl	$10, %edx              # устанавливаем базу системы счисления
      leaq	-72(%rbp), %rdi        # грузим адрес, откуда чистать строку
      call	strtoul


      leaq	-72(%rbp), %rdx        # сравниваем прочитаное с тем, что получили на вход
      cmpq	 %rdx, %rax
      jne	     success
      jmp      exit

#+END_SRC

Выход из проги:
#+NAME: exit
#+BEGIN_SRC asm
  exit:
      add     $200, %rsp
      movl	$0, %eax
      leave
      ret

#+END_SRC

Успешное продолжение проги:
- сохранить число, полученное из строки
- установить счетчик в 64. 64 - потому что у нас максмум 64 бита в
  числе может быть по умолчанию. Счетчик понадобится, чтоб считать биты в
  числе, прочитанном с консоли.

#+NAME: success
#+BEGIN_SRC asm
  success:
      mov	    %rax, -80(%rbp)        # сохранили число, полученное из строки

      mov     $64, %rcx                # установили счетчик
#+END_SRC

Считаем кол-во битов в числе:

С помощью ~rcl~ последовательно сдвигаем биты влево через влаг ~cf~, пока
не встретим первую единицу. Так мы "проматываем" нулевые старшие
разряды. На каждой итерации счетчик декрементируется. Как только мы
встречаем первую единицу, мы считаем, что добрались до самого числа и
перестаем считать, сохраняя значение счетчика в стеке - теперь мы знаем,
сколько бит занимает число

#+NAME: count_bits
#+BEGIN_SRC asm
  count_bits:                        # считаем, сколько бит занимает число
      rcl     $1, %rax
      jb      stop_count
      dec     %rcx
      jmp     count_bits

  stop_count:
      mov	    %rcx, -88(%rbp)        # сохранили кол-во бит, которое занимает число
#+END_SRC

Выделяем память:
Чтоб выделить память на все возможные числа от 0 до максимума, заданного
юзером, пользуемся следующей схемой:
1. мы выводим числа в бинарном представлении как строки. Т.е. число 5
  будет выведено как "101". Следовательно, каждый бит числа начинает
  занимать байт - именно столько занимает аски-код одного
  символа. Значит, техбитовое число как строка будет занимать 3 байта +
  перевод строки.
2. чтоб понять, сколько байт надо выделить на все числа, мы считаем по
  следующей схеме:  (кол-во бит в числе + 1) * число

Например,юзер ввел число 5. От 0 до 5 у нас будет 5 чисел, каждое из
которых занимает 3 бита. Значит, как строка каждое число будет занимать 3
байта + перевод строки.
Итого (3 + 1) * 5 = 20 байт.

#+NAME: allocate_memory
#+BEGIN_SRC asm
  allocate_memory:                   # выделяем память
      mov     -80(%rbp), %rax

      add      $1, %rcx              # добавляем 1, чтоб учесть перевод строки
      mov      %rcx, -126(%rbp)      # сохранили сколько байт приходится на число с "\n"
      mov      $0, %rsi
      mov      %rsi,-134(%rbp)       # установили счетчик заполняемости выделенной памяти

      imul     %rax, %rcx            # посчитали, сколько байт нужно для всех чисел от
                                     # 0 до прочитанного из stdin

      mov	    %rcx, -142(%rbp)       # сохранили это кол-во байт

      mov	    -142(%rbp), %rdi       # выделяем нужное кол-во памяти
      call	malloc

      cmp     $0, %rax               # проверяем возвращенный указатель
      je      allocation_error
#+END_SRC

Если юзер ввел слишком большое число, то памяти нам не хватит, и тогда
~malloc~ вернет нулевой указатель.Мы обработаем ошибку и выйдем из
проги.

#+NAME: allocation_error
#+BEGIN_SRC asm
  allocation_error:                        # в случае если память выделить не удалось

      mov	    $allocation_error_msg, %rdi  # печатаем сообщение об ошибке и выходим из проги
      movl	$0, %eax
      call	puts
      jmp     exit

#+END_SRC

Если выделение памяти прошло успешно, мы сохраняем указатель на нее в
стеке, а затем готовимся генерировать числа от 0 до заданого максимума и
число-проверку.

#+NAME: allocation_success
#+BEGIN_SRC asm
  allocation_success:
      mov     %rax, -102(%rbp)       # сохранили указатель на выделенную память
      mov     %rax, -118(%rbp)

      mov     $0, %rbx               # загрузили начальное значение для генератора чисел
      mov     %rbx, -110(%rbp)

      mov     $0b1100000000000000000000000000000000000000000000000000000000000000, %rdx
      mov    -88(%rbp), %rcx

      mov     $64, %rax
      sub     %rcx, %rax

      jmp     create_check_number

#+END_SRC

Изначально мы установили число-проверку для 8-байтового значения. Но наше
число может быть значительно меньше. Поэтому мы будем сдвигать биты
числа-проверки до тех пор, пока оно не станет одного размера с числом,
полученным на входе.

#+NAME: create_check_number
#+BEGIN_SRC asm
  create_check_number:                     # создаем число-проверку
      shr     $1, %rdx
      dec     %rax

      cmp     $0, %rax
      jne     create_check_number

      mov     %rdx, -150(%rbp)             # сохраняем число-проверку
      mov     %rdx, -158(%rbp)

#+END_SRC

Теперь можно генерировать числа от 0 до заданного на входе.
После каждого сгенеренного числа мы будем его сразу проверять.

#+NAME: generate_params
#+BEGIN_SRC asm
  generate_params:                   # генерируем числа-параметры
      mov   -110(%rbp), %rbx         # получили текущее значение
      cmp   -80(%rbp), %rbx          # сравниваем с введенным пользователем числом
      je     print_in_stdout         # если равны - мы досигли максимума, выход

      inc    %rbx                    # иначе увеличить значение
      mov    %rbx, -110(%rbp)        # сохранить обновленное значение в стеке

      mov    -150(%rbp), %rax
      mov    %rax, -158(%rbp)

#+END_SRC

Собственно, вот и сама проверка числа:
получаем число-параметр и число проверку и начинаем их накладывать друг
на друга, сдвигая биты в числе-проверке на 1 вправо каждый раз,пока либо
не дойдем до конца числа, либо не встретим соседние единицы

#+NAME: loop
#+BEGIN_SRC asm
  loop:
      mov   -110(%rbp),  %rdx        # взяли число-парамер
      mov   -158(%rbp),  %rbx        # взяли число-проверку

      and   %rbx, %rdx               # обнулить лишние разряды, результат в rdx
      cmp   $1, -158(%rbp)
      je    prepare_num
      cmp   %rdx, -158(%rbp)
      je    generate_params

      mov   -158(%rbp),  %rbx
      shr    $1, %rbx
      mov    %rbx, -158(%rbp)
      jmp    loop

#+END_SRC

Если число подошло, то нам надо записать его в память.
Тут мы сталкиваемся с проблемами:
1. Мы не знаем, насколько число длинное
2. Если останется незаполненная память, мы не хотим печатать пустые байты
3. Мы не хотим печатать в память нулевые старшие разряды

Поэтому мы:
1. Вытаскиваем из стека счетчик бит числа, который сохранили ранее
2. Увеличиваем счетик заполненной памяти на кол-во бит числа
3. Пропускаем старшие нулевые разряды текущего числа

#+NAME: prep_scroll
#+BEGIN_SRC asm
  prepare_num:
      mov	    -88(%rbp), %rcx        # получили счетчик (сколько бит занимет число)
      mov     -110(%rbp), %rbx       # получили число-параметр

      mov     -126(%rbp), %rdx       # увечили счетчик заполняемости выделенной памяти
      add     %rdx, -134(%rbp)

      mov     $64, %rax              # высчитываем, сколько старших разрядов надо пропустить
      sub     %rcx, %rax
      mov     %rax, %rcx

  scroll_zero_bits:                 # сдвинули биты, чтоб пропустить старшие нулевые разряды
      rcl     $1, %rbx
      dec     %rcx
      cmp     $0, %rcx

      ja      scroll_zero_bits
      mov	    -88(%rbp), %rcx
#+END_SRC

Запись в память.
В память мы пишем побитово, прокручивая число с помощью ~rcl~. Если в
~cf~ оказался 0, то пишем в память "48" - аски-код нуля - если 1, то
"49" - аски-код единицы. Если число кончилось, то пишем "10" - аски-код
пробела

#+NAME:  print_num_into_memory
#+BEGIN_SRC asm
  print_num_into_memory:            # заполняем выделенную память числами
      rcl     $1, %rbx
      dec     %rcx

      jnb     print_0               # если влаг cf = 0, то идем печатать 0, иначе 1

  print_1:
      mov     -118(%rbp), %rax      # получаем адрес, куда будем записывать число

      movl     $49, (%rax)          # записываем его аски-код

      add     $1, %rax              # сдвигаемся на 1 байт и сохраняем новый указатель
      mov     %rax, -118(%rbp)

      cmp     $0, %rcx              # число кончилось?
      jne     print_num_into_memory # нет, печаетаем дальше

      movl    $10, (%rax)           # иначе записать аски-код перевода строки
      add     $1, %rax              # сдвинуться на байт и сохранить новый указатель
      mov     %rax, -118(%rbp)

      jmp     generate_params       # генерим новое число

  print_0:                          # все аналогично, только в память пишется 0
      mov     -118(%rbp), %rax

      movl     $48, (%rax)

      add     $1, %rax
      mov     %rax, -118(%rbp)

      cmp     $0, %rcx
      jne     print_num_into_memory

      movl    $10, (%rax)
      add     $1, %rax
      mov     %rax, -118(%rbp)

      jmp      generate_params

#+END_SRC

Когда все числа проанализированны и нужные записаны в память, мы выводим
их с помщью ~write~ в бинарном формате

#+NAME: print_in_stdout
#+BEGIN_SRC asm
  print_in_stdout:                 # вывод всех чисел из выделенной памяти
      mov $1, %rdi
      mov -102(%rbp), %rsi
      mov -134(%rbp), %rdx

      call write

#+END_SRC

~сборка~
#+NAME: print_in_stdout
#+BEGIN_SRC asm :tangle asm-version.S :noweb yes tangle :exports code :padline no :comments none
  <<head>>
  <<main>>
  <<success>>
  <<count_bits>>
  <<allocate_memory>>
  <<allocation_success>>
  <<allocation_error>>
  <<create_check_number>>
  <<generate_params>>
  <<loop>>
  <<prep_scroll>>
  <<print_num_into_memory>>
  <<print_in_stdout>>
  <<exit>>
#+END_SRC
